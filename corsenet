import os
import glob

# Path to the folder where images are located
folder = r"C:/Users/2179048/Downloads/MinutiaeNet-master/MinutiaeNet-master/Dataset/CoarseNet_test"

# Correct path construction for img_files folder
img_files_path = os.path.join(folder, 'img_files', '*.bmp')

# Verify the folder and images
print(f"Looking for BMP images in: {img_files_path}")

# Use glob to list all BMP files in the img_files folder
img_files = glob.glob(img_files_path)

# Check if images are found
if not img_files:
    raise ValueError(f"No images found in folder: {img_files_path}")

# Now, proceed with your loop to process the images
for i, deploy_set in enumerate(inference_set):
    set_name = deploy_set.split('/')[-2]
    
    # Read image and GT
    img_name, folder_name, img_size = get_maximum_img_size_and_names(deploy_set)
    
    # Create directories (make sure to use os.makedirs if directories do not exist)
    os.makedirs(os.path.join(output_dir, set_name), exist_ok=True)
    os.makedirs(os.path.join(output_dir, set_name, 'mnt_results'), exist_ok=True)
    os.makedirs(os.path.join(output_dir, set_name, 'seg_results'), exist_ok=True)
    os.makedirs(os.path.join(output_dir, set_name, 'OF_results'), exist_ok=True)

    logging.info(f"Predicting \"{set_name}\":")
    
    main_net_model = CoarseNetmodel((None, None, 1), CoarseNet_path, mode='deploy')
    
    # Load FineNet if needed
    if isHavingFineNet:
        model_FineNet = FineNetmodel(num_classes=2, pretrained_path=FineNet_path, input_shape=(224, 224, 3))
        model_FineNet.compile(loss='categorical_crossentropy', optimizer=Adam(lr=0), metrics=['accuracy'])

    for i in range(len(img_name)):
        logging.info(f"\"{set_name}\" {i + 1}/{len(img_name)}: {img_name[i]}")

        # Load the image (Ensure the path is correct)
        image = misc.imread(os.path.join(deploy_set, 'img_files', f"{img_name[i]}.bmp"), mode='L')

        # Process image and run the model
        img_size = image.shape
        img_size = np.array(img_size, dtype=np.int32) // 8 * 8
        image = image[:img_size[0], :img_size[1]]

        original_image = image.copy()

        # Further processing and model predictions
        texture_img = FastEnhanceTexture(image, sigma=2.5, show=False)
        dir_map, fre_map = get_maps_STFT(texture_img, patch_size=64, block_size=16, preprocess=True)
        
        image = np.reshape(image, [1, image.shape[0], image.shape[1], 1])

        enh_img, enh_img_imag, enhance_img, ori_out_1, ori_out_2, seg_out, mnt_o_out, mnt_w_out, mnt_h_out, mnt_s_out \
            = main_net_model.predict(image)

        # Process output
        round_seg = np.round(np.squeeze(seg_out))
        seg_out = 1 - round_seg
        kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (10, 10))
        seg_out = cv2.morphologyEx(seg_out, cv2.MORPH_CLOSE, kernel)
        kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (7, 7))
        seg_out = cv2.morphologyEx(seg_out, cv2.MORPH_OPEN, kernel)
        kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (5, 5))
        seg_out = cv2.dilate(seg_out, kernel)

        # Minutiae extraction (adaptive threshold)
        final_minutiae_score_threashold = 0.45
        early_minutiae_thres = final_minutiae_score_threashold + 0.05

        while final_minutiae_score_threashold >= 0:
            mnt = label2mnt(np.squeeze(mnt_s_out) * np.round(np.squeeze(seg_out)), mnt_w_out, mnt_h_out, mnt_o_out,
                            thresh=early_minutiae_thres)
            mnt_nms_1 = py_cpu_nms(mnt, 0.5)
            mnt_nms_2 = nms(mnt)
            
            if mnt_nms_1.shape[0] > 4 and mnt_nms_2.shape[0] > 4:
                break
            else:
                final_minutiae_score_threashold = final_minutiae_score_threashold - 0.05
                early_minutiae_thres = early_minutiae_thres - 0.05

        mnt_nms = fuse_nms(mnt_nms_1, mnt_nms_2)
        mnt_nms = mnt_nms[mnt_nms[:, 3] > early_minutiae_thres, :]
        mnt_refined = []

        if isHavingFineNet:
            patch_minu_radio = 22
            if FineNet_path is not None:
                for idx_minu in range(mnt_nms.shape[0]):
                    try:
                        # Process each minutiae using FineNet
                        x_begin = int(mnt_nms[idx_minu, 1]) - patch_minu_radio
                        y_begin = int(mnt_nms[idx_minu, 0]) - patch_minu_radio
                        patch_minu = original_image[x_begin:x_begin + 2 * patch_minu_radio,
                                                    y_begin:y_begin + 2 * patch_minu_radio]

                        patch_minu = cv2.resize(patch_minu, dsize=(224, 224), interpolation=cv2.INTER_NEAREST)

                        ret = np.empty((patch_minu.shape[0], patch_minu.shape[1], 3), dtype=np.uint8)
                        ret[:, :, 0] = patch_minu
                        ret[:, :, 1] = patch_minu
                        ret[:, :, 2] = patch_minu
                        patch_minu = ret
                        patch_minu = np.expand_dims(patch_minu, axis=0)

                        [isMinutiaeProb] = model_FineNet.predict(patch_minu)
                        isMinutiaeProb = isMinutiaeProb[0]
                        tmp_mnt = mnt_nms[idx_minu, :].copy()
                        tmp_mnt[3] = (4 * tmp_mnt[3] + isMinutiaeProb) / 5
                        mnt_refined.append(tmp_mnt)

                    except:
                        mnt_refined.append(mnt_nms[idx_minu, :])

        else:
            mnt_refined = mnt_nms

        mnt_nms = np.array(mnt_refined)
        if mnt_nms.shape[0] > 0:
            mnt_nms = mnt_nms[mnt_nms[:, 3] > final_minutiae_score_threashold, :]

        final_mask = ndimage.zoom(np.round(np.squeeze(seg_out)), [8, 8], order=0)

        # Show orientation and results
        show_orientation_field(original_image, dir_map + np.pi, mask=final_mask, fname=os.path.join(output_dir, set_name, 'OF_results', f"{img_name[i]}_OF.jpg"))
        fuse_minu_orientation(dir_map, mnt_nms, mode=3)

        mnt_writer(mnt_nms, img_name[i], img_size, os.path.join(output_dir, set_name, 'mnt_results', f"{img_name[i]}.mnt"))
        draw_minutiae(original_image, mnt_nms, os.path.join(output_dir, set_name, f"{img_name[i]}_minu.jpg"), saveimage=True)

        misc.imsave(os.path.join(output_dir, set_name, 'seg_results', f"{img_name[i]}_seg.jpg"), final_mask)
