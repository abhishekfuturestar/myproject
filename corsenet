from __future__ import absolute_import, division

from tensorflow.keras.models import Model
from tensorflow.keras.layers import (
    Activation,
    AveragePooling2D,
    BatchNormalization,
    Concatenate,
    Conv2D,
    Dense,
    GlobalAveragePooling2D,
    Input,
    Lambda,
    MaxPooling2D,
)
from tensorflow.keras.applications.imagenet_utils import preprocess_input
from tensorflow.keras import backend as K
import matplotlib.pyplot as plt
import numpy as np
import itertools


def conv2d_bn(
    x,
    filters,
    kernel_size,
    strides=1,
    padding="same",
    activation="relu",
    use_bias=False,
    name=None,
):
    """Utility function to apply Conv2D + BatchNormalization."""
    x = Conv2D(
        filters,
        kernel_size,
        strides=strides,
        padding=padding,
        use_bias=use_bias,
        name=name,
    )(x)
    if not use_bias:
        bn_axis = 1 if K.image_data_format() == "channels_first" else 3
        bn_name = None if name is None else name + "_bn"
        x = BatchNormalization(axis=bn_axis, scale=False, name=bn_name)(x)
    if activation is not None:
        ac_name = None if name is None else name + "_ac"
        x = Activation(activation, name=ac_name)(x)
    return x


def inception_resnet_block(x, scale, block_type, block_idx, activation="relu"):
    """Inception-ResNet block."""
    if block_type == "block35":
        branch_0 = conv2d_bn(x, 32, 1)
        branch_1 = conv2d_bn(x, 32, 1)
        branch_1 = conv2d_bn(branch_1, 32, 3)
        branch_2 = conv2d_bn(x, 32, 1)
        branch_2 = conv2d_bn(branch_2, 48, 3)
        branch_2 = conv2d_bn(branch_2, 64, 3)
        branches = [branch_0, branch_1, branch_2]
    elif block_type == "block17":
        branch_0 = conv2d_bn(x, 192, 1)
        branch_1 = conv2d_bn(x, 128, 1)
        branch_1 = conv2d_bn(branch_1, 160, [1, 7])
        branch_1 = conv2d_bn(branch_1, 192, [7, 1])
        branches = [branch_0, branch_1]
    elif block_type == "block8":
        branch_0 = conv2d_bn(x, 192, 1)
        branch_1 = conv2d_bn(x, 192, 1)
        branch_1 = conv2d_bn(branch_1, 224, [1, 3])
        branch_1 = conv2d_bn(branch_1, 256, [3, 1])
        branches = [branch_0, branch_1]
    else:
        raise ValueError(
            f"Unknown block type: {block_type}. Use 'block35', 'block17', or 'block8'."
        )

    block_name = block_type + "_" + str(block_idx)
    channel_axis = 1 if K.image_data_format() == "channels_first" else 3
    mixed = Concatenate(axis=channel_axis, name=block_name + "_mixed")(branches)
    up = conv2d_bn(
        mixed,
        K.int_shape(x)[channel_axis],
        1,
        activation=None,
        use_bias=True,
        name=block_name + "_conv",
    )

    x = Lambda(
        lambda inputs, scale: inputs[0] + inputs[1] * scale,
        output_shape=K.int_shape(x)[1:],
        arguments={"scale": scale},
        name=block_name,
    )([x, up])
    if activation is not None:
        x = Activation(activation, name=block_name + "_ac")(x)
    return x


def FineNetmodel(num_classes=2, pretrained_path=None, input_shape=(299, 299, 3)):
    """Creates the FineNet architecture."""
    img_input = Input(shape=input_shape)

    # Stem block
    x = conv2d_bn(img_input, 32, 3, strides=2, padding="valid")
    x = conv2d_bn(x, 32, 3, padding="valid")
    x = conv2d_bn(x, 64, 3)
    x = MaxPooling2D(3, strides=2)(x)
    x = conv2d_bn(x, 80, 1, padding="valid")
    x = conv2d_bn(x, 192, 3, padding="valid")
    x = MaxPooling2D(3, strides=2)(x)

    # Inception-ResNet blocks
    for block_idx in range(1, 11):
        x = inception_resnet_block(x, scale=0.17, block_type="block35", block_idx=block_idx)

    # Final layers
    x = GlobalAveragePooling2D(name="avg_pool")(x)
    x = Dense(num_classes, activation="softmax", name="predictions")(x)

    model = Model(img_input, x, name="FineNet")

    # Load pretrained weights if provided
    if pretrained_path:
        print(f"Loading weights from {pretrained_path}")
        model.load_weights(pretrained_path)

    return model


def plot_confusion_matrix(
    cm, classes, normalize=False, title="Confusion matrix", cmap=plt.cm.Blues
):
    """Plot and visualize a confusion matrix."""
    plt.imshow(cm, interpolation="nearest", cmap=cmap)
    plt.title(title)
    plt.colorbar()
    tick_marks = np.arange(len(classes))
    plt.xticks(tick_marks, classes, rotation=45)
    plt.yticks(tick_marks, classes)

    if normalize:
        cm = cm.astype("float") / cm.sum(axis=1)[:, np.newaxis]
        print("Normalized confusion matrix")
    else:
        print("Confusion matrix, without normalization")

    print(cm)

    thresh = cm.max() / 2.0
    for i, j in itertools.product(range(cm.shape[0]), range(cm.shape[1])):
        plt.text(
            j,
            i,
            cm[i, j],
            horizontalalignment="center",
            color="white" if cm[i, j] > thresh else "black",
        )

    plt.tight_layout()
    plt.ylabel("True label")
    plt.xlabel("Predicted label")
    plt.show()
