import numpy as np
import imageio
from functools import reduce, partial
from multiprocessing import Pool
from scipy import ndimage, signal
import tensorflow as tf
from tensorflow.keras import backend as K
from scipy.sparse import coo_matrix

# Helper function to read images
def read_image(filepath, mode='L'):
    try:
        img = imageio.imread(filepath, pilmode=mode)
    except FileNotFoundError:
        img = None
    return img

# Sub-load data function
def sub_load_data(data, img_size, aug):
    img_name, dataset = data

    img = read_image(f"{dataset}img_files/{img_name}.bmp", mode='L')
    if img is None:
        raise ValueError(f"Image file {img_name}.bmp not found.")

    seg = read_image(f"{dataset}seg_files/{img_name}.bmp", mode='L')
    if seg is None:
        seg = np.ones_like(img)

    ali = read_image(f"{dataset}ori_files/{img_name}.jpg", mode='L')
    if ali is None:
        ali = np.zeros_like(img)

    mnt = np.array(mnt_reader(f"{dataset}mnt_files/{img_name}.mnt"), dtype=float)

    if any(img.shape != img_size):
        if np.random.rand() < aug:
            tra = np.int32(np.random.rand(2) * (np.array(img_size) - np.array(img.shape)))
        else:
            tra = np.int32(0.5 * (np.array(img_size) - np.array(img.shape)))

        img_t = np.ones(img_size) * np.mean(img)
        seg_t = np.zeros(img_size)
        ali_t = np.ones(img_size) * np.mean(ali)

        img_t[tra[0]:tra[0] + img.shape[0], tra[1]:tra[1] + img.shape[1]] = img
        seg_t[tra[0]:tra[0] + img.shape[0], tra[1]:tra[1] + img.shape[1]] = seg
        ali_t[tra[0]:tra[0] + img.shape[0], tra[1]:tra[1] + img.shape[1]] = ali

        img = img_t
        seg = seg_t
        ali = ali_t
        mnt = mnt + np.array([tra[1], tra[0], 0])

    if np.random.rand() < aug:
        rot = np.random.rand() * 360
        tra = (np.random.rand(2) - 0.5) / 2 * img_size

        img = ndimage.rotate(img, rot, reshape=False, mode='reflect')
        img = ndimage.shift(img, tra, mode='reflect')
        seg = ndimage.rotate(seg, rot, reshape=False, mode='constant')
        seg = ndimage.shift(seg, tra, mode='constant')
        ali = ndimage.rotate(ali, rot, reshape=False, mode='reflect')
        ali = ndimage.shift(ali, tra, mode='reflect')

        mnt_r = point_rot(mnt[:, :2], rot / 180 * np.pi, img.shape, img.shape)
        mnt = np.column_stack((mnt_r + tra[[1, 0]], mnt[:, 2] - rot / 180 * np.pi))

    mnt = mnt[(8 <= mnt[:, 0]) * (mnt[:, 0] < img_size[1] - 8) * (8 <= mnt[:, 1]) * (mnt[:, 1] < img_size[0] - 8), :]
    return img, seg, ali, mnt

# Main load data function
def load_data(dataset, tra_ori_model, rand=False, aug=0.0, batch_size=1, sample_rate=None):
    if isinstance(dataset[0], str):
        img_name, folder_name, img_size = get_maximum_img_size_and_names(dataset, sample_rate)
    else:
        img_name, folder_name, img_size = dataset

    if rand:
        rand_idx = np.arange(len(img_name))
        np.random.shuffle(rand_idx)
        img_name = img_name[rand_idx]
        folder_name = folder_name[rand_idx]

    if batch_size > 1 and use_multiprocessing:
        p = Pool(batch_size)

    p_sub_load_data = partial(sub_load_data, img_size=img_size, aug=aug)

    for i in range(0, len(img_name), batch_size):
        have_alignment = np.ones([batch_size, 1, 1, 1])
        image = np.zeros((batch_size, img_size[0], img_size[1], 1))
        segment = np.zeros((batch_size, img_size[0], img_size[1], 1))
        alignment = np.zeros((batch_size, img_size[0], img_size[1], 1))

        minutiae_w = np.zeros((batch_size, img_size[0] // 8, img_size[1] // 8, 1)) - 1
        minutiae_h = np.zeros((batch_size, img_size[0] // 8, img_size[1] // 8, 1)) - 1
        minutiae_o = np.zeros((batch_size, img_size[0] // 8, img_size[1] // 8, 1)) - 1

        batch_name = [img_name[(i + j) % len(img_name)] for j in range(batch_size)]
        batch_f_name = [folder_name[(i + j) % len(img_name)] for j in range(batch_size)]

        if batch_size > 1 and use_multiprocessing:
            results = p.map(p_sub_load_data, zip(batch_name, batch_f_name))
        else:
            results = map(p_sub_load_data, zip(batch_name, batch_f_name))

        for j, (img, seg, ali, mnt) in enumerate(results):
            if np.sum(ali) == 0:
                have_alignment[j, 0, 0, 0] = 0
            image[j, :, :, 0] = img / 255.0
            segment[j, :, :, 0] = seg / 255.0
            alignment[j, :, :, 0] = ali / 255.0

            valid_idx = (mnt[:, 1] // 8).astype(int), (mnt[:, 0] // 8).astype(int)
            minutiae_w[j][valid_idx] = mnt[:, 0] % 8
            minutiae_h[j][valid_idx] = mnt[:, 1] % 8
            minutiae_o[j][valid_idx] = mnt[:, 2]

        # Other processing as required.
        yield image, alignment, batch_name

    if batch_size > 1 and use_multiprocessing:
        p.close()
        p.join()
    return
