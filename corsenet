import os
import numpy as np
import cv2
from datetime import datetime
from scipy import ndimage
from matplotlib import pyplot as plt
from tensorflow.keras.models import load_model
from tensorflow.keras.optimizers import Adam
from utils import (
    init_log, mkdir, get_maximum_img_size_and_names, 
    FastEnhanceTexture, get_maps_STFT, label2mnt, 
    py_cpu_nms, nms, fuse_nms, show_orientation_field, 
    fuse_minu_orientation, mnt_writer, draw_minutiae
)

# Set parameters and paths
inference_set = ['../Dataset/prints_to_test_25/']
CoarseNet_path = '../Models/CoarseNet.h5'
FineNet_path = '../Models/FineNet.h5'
output_dir = '../output_CoarseNet_25/' + datetime.now().strftime('%Y%m%d-%H%M%S')
isHavingFineNet = False

# Initialize logging
logging = init_log(output_dir)

# Iterate over each dataset
for deploy_set in inference_set:
    set_name = deploy_set.split('/')[-2]

    # Get image details
    img_name, folder_name, img_size = get_maximum_img_size_and_names(deploy_set)
    
    # Create necessary directories
    mkdir(output_dir + '/' + set_name + '/')
    mkdir(output_dir + '/' + set_name + '/mnt_results/')
    mkdir(output_dir + '/' + set_name + '/seg_results/')
    mkdir(output_dir + '/' + set_name + '/OF_results/')
    mkdir(output_dir + '/' + set_name + '/enhance_img_results/')

    logging.info(f"Predicting \"{set_name}\":")

    # Load CoarseNet model
    main_net_model = load_model(CoarseNet_path)

    # Load FineNet model if needed
    if isHavingFineNet:
        model_FineNet = load_model(FineNet_path)
        model_FineNet.compile(
            loss='categorical_crossentropy',
            optimizer=Adam(lr=0),
            metrics=['accuracy']
        )

    # Process each image in the dataset
    for i in range(len(img_name)):
        logging.info(f"\"{set_name}\" {i + 1} / {len(img_name)}: {img_name[i]}")
        image = cv2.imread(deploy_set + 'img_files/' + img_name[i] + '.bmp', cv2.IMREAD_GRAYSCALE)
        img_size = np.array(image.shape, dtype=np.int32) // 8 * 8
        image = image[:img_size[0], :img_size[1]]
        original_image = image.copy()

        # Enhance texture and get maps
        texture_img = FastEnhanceTexture(image, sigma=2.5, show=False)
        dir_map, fre_map = get_maps_STFT(texture_img, patch_size=64, block_size=16, preprocess=True)

        image = np.reshape(image, [1, image.shape[0], image.shape[1], 1])

        # Predict using CoarseNet
        outputs = main_net_model.predict(image)
        enh_img, enhance_img = outputs[1], outputs[2]

        # Normalize and save enhanced image
        enhance_img = np.squeeze(enhance_img)
        min_val, max_val = np.min(enhance_img), np.max(enhance_img)
        if max_val - min_val > 0:
            enhance_img = (enhance_img - min_val) / (max_val - min_val) * 255
        else:
            enhance_img = np.zeros_like(enhance_img)
        enhance_img = enhance_img.astype(np.uint8)

        enhance_img_output_path = f"{output_dir}/{set_name}/enhance_img_results/{img_name[i]}_enhance_img.jpg"
        plt.imsave(enhance_img_output_path, enhance_img, cmap='gray')
        print(f"Enhanced image saved to {enhance_img_output_path}")

        # Process segmentation, minutiae detection, and orientation field
        round_seg = np.round(np.squeeze(outputs[6]))
        seg_out = 1 - round_seg
        kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (10, 10))
        seg_out = cv2.morphologyEx(seg_out, cv2.MORPH_CLOSE, kernel)
        kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (7, 7))
        seg_out = cv2.morphologyEx(seg_out, cv2.MORPH_OPEN, kernel)
        kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (5, 5))
        seg_out = cv2.dilate(seg_out, kernel)

        # Save segmentation result
        final_mask = ndimage.zoom(np.round(np.squeeze(seg_out)), [8, 8], order=0)
        plt.imsave(f"{output_dir}/{set_name}/seg_results/{img_name[i]}_seg.jpg", final_mask, cmap='gray')

        # Minutiae detection and refinement
        final_minutiae_score_threshold = 0.45
        mnt_nms = outputs[10]
        fuse_minu_orientation(dir_map, mnt_nms, mode=3)
        mnt_writer(mnt_nms, img_name[i], img_size, f"{output_dir}/{set_name}/mnt_results/{img_name[i]}.mnt")
        draw_minutiae(original_image, mnt_nms, f"{output_dir}/{set_name}/{img_name[i]}_minu.jpg", saveimage=True)

        # Save orientation field result
        show_orientation_field(
            original_image, dir_map + np.pi, mask=final_mask,
            fname=f"{output_dir}/{set_name}/OF_results/{img_name[i]}_OF.jpg"
        )

    logging.info(f"Finished processing \"{set_name}\".")
