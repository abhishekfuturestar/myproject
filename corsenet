for i in range(0, len(img_name)):

    logging.info("\"%s\" %d / %d: %s" % (set_name, i + 1, len(img_name), img_name[i]))

    image = imread(deploy_set + 'img_files/' + img_name[i] + '.bmp', mode='L')  # Load the image
    img_size = image.shape
    img_size = np.array(img_size, dtype=np.int32) // 8 * 8
    image = image[:img_size[0], :img_size[1]]

    original_image = image.copy()

    # Generate OF
    texture_img = FastEnhanceTexture(image, sigma=2.5, show=False)
    dir_map, fre_map = get_maps_STFT(texture_img, patch_size=64, block_size=16, preprocess=True)

    image = np.reshape(image, [1, image.shape[0], image.shape[1], 1])

    # Predict using the main network model
    enh_img, enh_img_imag, enhance_img, ori_out_1, ori_out_2, seg_out, mnt_o_out, mnt_w_out, mnt_h_out, mnt_s_out = main_net_model.predict(image)

    # Debug: Check shape and values of enhance_img
    logging.info(f"Shape of enhance_img: {enhance_img.shape}")
    logging.info(f"Data range of enhance_img: min={enhance_img.min()}, max={enhance_img.max()}")

    # Process enhance_img for visualization (ensure it is 2D and normalized)
    enhance_img_vis = np.squeeze(enhance_img)  # Remove single dimensions
    if enhance_img_vis.max() > 1:  # Normalize if values are greater than 1
        enhance_img_vis = enhance_img_vis / enhance_img_vis.max()

    # Save the enhanced image
    output_path = f"{output_dir}/{set_name}/enhance_img_results/{img_name[i]}_enhance_img.jpg"
    plt.imsave(output_path, enhance_img_vis, cmap='gray')
    logging.info(f"Enhanced image saved at: {output_path}")
